<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>继承 | 前端知识体系构建</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="楚岚博客">
    
    <link rel="preload" href="/vuepress-start/assets/css/0.styles.fcc2c73b.css" as="style"><link rel="preload" href="/vuepress-start/assets/js/app.8ee9e0f6.js" as="script"><link rel="preload" href="/vuepress-start/assets/js/2.cfb989c2.js" as="script"><link rel="preload" href="/vuepress-start/assets/js/20.b06e8df4.js" as="script"><link rel="preload" href="/vuepress-start/assets/js/7.a1edbbdd.js" as="script"><link rel="prefetch" href="/vuepress-start/assets/js/10.289482bb.js"><link rel="prefetch" href="/vuepress-start/assets/js/11.bc011218.js"><link rel="prefetch" href="/vuepress-start/assets/js/12.06f8fb72.js"><link rel="prefetch" href="/vuepress-start/assets/js/13.0842d756.js"><link rel="prefetch" href="/vuepress-start/assets/js/14.a19ed644.js"><link rel="prefetch" href="/vuepress-start/assets/js/15.be134613.js"><link rel="prefetch" href="/vuepress-start/assets/js/16.4e02c0fc.js"><link rel="prefetch" href="/vuepress-start/assets/js/17.3bb3e4b0.js"><link rel="prefetch" href="/vuepress-start/assets/js/18.efff4d5a.js"><link rel="prefetch" href="/vuepress-start/assets/js/19.55de0958.js"><link rel="prefetch" href="/vuepress-start/assets/js/3.050ec1ac.js"><link rel="prefetch" href="/vuepress-start/assets/js/4.f58268fa.js"><link rel="prefetch" href="/vuepress-start/assets/js/5.d621375d.js"><link rel="prefetch" href="/vuepress-start/assets/js/6.e73b1186.js"><link rel="prefetch" href="/vuepress-start/assets/js/8.ed420721.js"><link rel="prefetch" href="/vuepress-start/assets/js/9.511062bc.js">
    <link rel="stylesheet" href="/vuepress-start/assets/css/0.styles.fcc2c73b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-start/" class="home-link router-link-active"><!----> <span class="site-name">前端知识体系构建</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-start/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-start/guide/" class="nav-link">
  文档搭建
</a></div><div class="nav-item"><a href="/vuepress-start/js/base/inherit/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/vuepress-start/interview/html/1/" class="nav-link">
  前端面试
</a></div><div class="nav-item"><a href="/vuepress-start/engineering/module/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/vuepress-start/hand-wirte-code/promise/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="/vuepress-start/Git/rebase/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/vuepress-start/react-ssr/native-ssr/" class="nav-link">
  React-SSR
</a></div><div class="nav-item"><a href="https://github.com/Chulan-824" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-start/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-start/guide/" class="nav-link">
  文档搭建
</a></div><div class="nav-item"><a href="/vuepress-start/js/base/inherit/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/vuepress-start/interview/html/1/" class="nav-link">
  前端面试
</a></div><div class="nav-item"><a href="/vuepress-start/engineering/module/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/vuepress-start/hand-wirte-code/promise/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="/vuepress-start/Git/rebase/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/vuepress-start/react-ssr/native-ssr/" class="nav-link">
  React-SSR
</a></div><div class="nav-item"><a href="https://github.com/Chulan-824" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Js基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-start/js/base/inherit.html" aria-current="page" class="active sidebar-link">继承</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h1> <h2 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h2> <p>主要思想就是<code>通过原型继承多个引用类型的属性和方法</code></p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getParentValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>childProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getChildValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childProperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span><span class="token function">getParentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance2<span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span><span class="token function">getParentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="默认原型"><a href="#默认原型" class="header-anchor">#</a> 默认原型</h3> <p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实
现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向
Object.prototype。</p> <p>以上面例子可知，Child 继承 Parent，而 Parent 继承 Object。在调用 instance.toString()时，实
际上调用的是保存在 Object.prototype 上的方法。</p> <h3 id="原型与继承关系"><a href="#原型与继承关系" class="header-anchor">#</a> 原型与继承关系</h3> <p>确定原型与实例的关系可以通过两种方式来确定。</p> <blockquote><p>第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。如下例所示：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><blockquote><p>第二种方式是使用 isPrototypeOf() 方法。原型链中的每个原型都可以调用这个方法，如下例所示：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="关于方法"><a href="#关于方法" class="header-anchor">#</a> 关于方法</h3> <p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getParentValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>childproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token comment">// 继承 Parent </span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 新方法</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getChildValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childproperty<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token comment">// 覆盖已有的方法</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getParentValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getParentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>需要注意，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。下面是一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>childproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
 <span class="token comment">// 继承 Parent </span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 通过对象字面量添加新方法，这会导致上一行无效</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span> 
 <span class="token function">getSubValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childproperty<span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">,</span> 
 <span class="token function">someOtherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出错！</span>
</code></pre></div><h3 id="原型链的问题"><a href="#原型链的问题" class="header-anchor">#</a> 原型链的问题</h3> <blockquote><p>引用值共享
原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含<code>引用值</code>的时候，原型中包含的<code>引用值</code>会在所有实例间<code>共享</code>，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
 <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
 <span class="token comment">// 继承 Parent </span>
 <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green,black&quot; </span>
 <span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green,black&quot;</span>
</code></pre></div><blockquote><p>子类型在实例化时不能给父类型的构造函数传参</p></blockquote> <h2 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="header-anchor">#</a> 盗用构造函数继承</h2> <p>为了解决原型包含引用值导致的继承问题，一种叫作<code>盗用构造函数</code>（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作<code>对象伪装</code>或<code>经典继承</code>）。基本思路很简单：在子类构造函数中调用父类构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token comment">// 继承 Parent </span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green,black&quot; </span>
<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green&quot;</span>
</code></pre></div><h3 id="传递参数"><a href="#传递参数" class="header-anchor">#</a> 传递参数</h3> <p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
<span class="token comment">// 继承 Parent 并传参</span>
<span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 实例属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Nicholas&quot;; </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29 </span>
</code></pre></div><h3 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="header-anchor">#</a> 盗用构造函数的问题</h3> <p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p> <p>优点：</p> <blockquote><ol><li>可以在子类构造函数中向父类传参数</li> <li>父类的引用属性不会被共享</li></ol></blockquote> <p>缺点：</p> <blockquote><ol><li>子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化</li></ol></blockquote> <h2 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h2> <p>组合继承（有时候也叫伪经典继承）综合了<code>原型链</code>和<code>盗用构造函数</code>，将两者的优点集中了起来。基
本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token comment">// 继承属性</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二次调用 Parent()</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token comment">// 继承方法</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一次调用 Parent()</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green,black&quot; </span>
instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Nicholas&quot;; </span>
instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29 </span>
<span class="token keyword">let</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;red,blue,green&quot; </span>
instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Greg&quot;;</span>
</code></pre></div><p>优点：</p> <blockquote><ol><li>父类的方法可以复用</li> <li>可以在Child构造函数中向Parent构造函数中传参</li> <li>父类构造函数中的引用属性不会被共享</li></ol></blockquote> <p>缺点：</p> <blockquote><ol><li>父构造函数之中会被调用两次（一次在是创建子类原型时调用，另一次是在子类构造函数中调用）</li></ol></blockquote> <h2 id="原型式继承"><a href="#原型式继承" class="header-anchor">#</a> 原型式继承</h2> <p>即使不自定义类型也可以通过原型实现对象之间的信息共享</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
 <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span> 
 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次<code>浅复制</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> 
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> 
  <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> 
person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span> 
person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Rob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> person2 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> 
person2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Linda&quot;</span><span class="token punctuation">;</span> 
person2<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Barbie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span>
</code></pre></div><p>优点：</p> <blockquote><ol><li>父类方法可复用</li></ol></blockquote> <p>缺点:</p> <blockquote><ol><li>父类的引用会被所有子类所共享</li> <li>子类实例不能向父类传参</li></ol></blockquote> <blockquote><p>ES5的Object.create()方法在只有第一个参数时，与这里的object()方法效果相同</p></blockquote> <h2 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h2> <p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过调用函数创建一个新对象</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 以某种方式增强这个对象</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">;</span> 
 <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> 
 <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> 
 <span class="token literal-property property">friends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> 
anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;hi&quot; </span>
</code></pre></div><p>注意: 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p> <h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="header-anchor">#</a> 寄生式组合继承</h2> <p>通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">Child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建对象</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span> <span class="token comment">// 增强对象 </span>
  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">// 赋值对象</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>优点：</p> <blockquote><ol><li>只调用一次父类构造函数</li> <li>Child可以向Parent传参</li> <li>父类方法可以复用</li> <li>父类的引用属性不会被共享</li></ol></blockquote> <blockquote><p>寄生式组合继承可以算是引用类型继承的最佳模式</p></blockquote> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <table><thead><tr><th>模式</th> <th>优点</th> <th>缺点</th></tr></thead> <tbody><tr><td>原型链继承</td> <td>1. 父类方法可以复用</td> <td>1. 父类的所有引用属性会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响 <br> 2. 子类型实例不能给父类型构造函数传参</td></tr> <tr><td>盗用构造函数继承</td> <td>1. 可以在子类构造函数中向父类传参数 <br> 2. 父类的引用属性不会被共享</td> <td>1. 子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化</td></tr> <tr><td>组合继承</td> <td>1. 父类的方法可以复用 <br>2. 可以在Child构造函数中向Parent构造函数中传参 <br> 3. 父类构造函数中的引用属性不会被共享</td> <td>1. 父构造函数之中会被调用两次（一次在是创建子类原型时调用，另一次是在子类构造函数中调用）</td></tr> <tr><td>原型式继承</td> <td>1. 父类方法可复用</td> <td>1. 父类的引用会被所有子类所共享 <br>2. 子类实例不能向父类传参</td></tr> <tr><td>寄生式继承</td> <td></td> <td></td></tr> <tr><td>寄生式组合继承</td> <td>1. 只调用一次父类构造函数<br>2. Child可以向Parent传参 <br> 3. 父类方法可以复用 <br> 4. 父类的引用属性不会被共享</td> <td></td></tr></tbody></table> <h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <p>《JavaScript高级程序设计第4版》</p> <p><a href="https://juejin.cn/post/6914216540468576263#heading-4" target="_blank" rel="noopener noreferrer">JS继承 原型链继承、构造函数继承、组合继承、原型继承、寄生式继承、寄生组合继承<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="sideTitle" data-v-07ed83de><div class="title" data-v-07ed83de>继承</div> <hr data-v-07ed83de> <ul data-v-07ed83de><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#原型链继承" data-v-07ed83de>原型链继承</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#实现" data-v-07ed83de>实现</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#默认原型" data-v-07ed83de>默认原型</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#原型与继承关系" data-v-07ed83de>原型与继承关系</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#关于方法" data-v-07ed83de>关于方法</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#原型链的问题" data-v-07ed83de>原型链的问题</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#盗用构造函数继承" data-v-07ed83de>盗用构造函数继承</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#传递参数" data-v-07ed83de>传递参数</a></li><li class="level-3" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#盗用构造函数的问题" data-v-07ed83de>盗用构造函数的问题</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#组合继承" data-v-07ed83de>组合继承</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#原型式继承" data-v-07ed83de>原型式继承</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#寄生式继承" data-v-07ed83de>寄生式继承</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#寄生式组合继承" data-v-07ed83de>寄生式组合继承</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#总结" data-v-07ed83de>总结</a></li><li class="level-2" data-v-07ed83de><a href="/vuepress-start/js/base/inherit.html#参考文章" data-v-07ed83de>参考文章</a></li></ul></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-start/assets/js/app.8ee9e0f6.js" defer></script><script src="/vuepress-start/assets/js/2.cfb989c2.js" defer></script><script src="/vuepress-start/assets/js/20.b06e8df4.js" defer></script><script src="/vuepress-start/assets/js/7.a1edbbdd.js" defer></script>
  </body>
</html>
